package entities.particles;

import java.util.Random;

import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.util.vector.Quaternion;
import org.lwjgl.util.vector.Vector3f;

import util.Noise;
import util.helper.QuaternionHelper;
import util.manager.TextureManager;
import entities.Entities;
import entities.Entity;

/**
 * Fancy-looking space debris effect using perlin noise.
 * @author TranquilMarmot
 * @see Entity
 *
 */
public class Debris extends Entity {
	/** array to hold all the stars */
	public Particle[] particles;

	/** random number generator */
	Random randy;

	/** the entity that the star field generates stars around */
	public Entity following;

	/** number of stars to have at a time */
	public int numStars;

	/** how far to draw the stars */
	public float distance;

	/**
	 * The random floats between 1.0f and 0.0f are multiplied by this when added
	 * to a random stars location. Making it a lot bigger makes the stars
	 * generate farther apart
	 */
	private final float JUMP_AMOUNT = 150000.0f;

	/**
	 * Create some cool space debris so you know which way you're going
	 * 
	 * @param following
	 *            The entity that the debris is being generated around
	 * @param numParticles
	 *            How many particles to generate
	 * @param distance
	 *            How far out to generate the particles
	 * @param seed
	 *            Seed for the random number generator
	 */
	public Debris(Entity following, int numParticles, float distance, long seed) {
		// initialize variables
		super();
		this.type = "debris";
		this.following = following;
		this.numStars = numParticles;
		this.distance = distance;
		
		rotation = new Quaternion(0.0f, 0.0f, 0.0f, 1.0f);
		// initialize the rotation buffer (this is used for billboarding the particles)
		rotationBuffer = BufferUtils.createFloatBuffer(16);
		
		// initialize random number generator
		randy = new Random(seed);

		// set the location of the debris field to the entity that it's following
		this.location.x = following.location.x;
		this.location.y = following.location.y;
		this.location.z = following.location.z;

		// each star is generated using the location of the previous star
		float prevX = location.x + randy.nextFloat() * 10.0f;
		float prevY = location.y + randy.nextFloat() * 10.0f;
		float prevZ = location.z - randy.nextFloat() * 100.0f;

		// initialize the array of particles
		particles = new Particle[numParticles];
		
		// fill the array
		for (int i = 0; i < numParticles; i++) {
			// generate a random particle and put it into the array
			Particle p = getRandomParticle(prevX, prevY, prevZ);
			particles[i] = p;
			// update the variables that keep track of previous particle location
			prevX = p.location.x;
			prevY = p.location.y;
			prevZ = p.location.z;
		}
	}

	/**
	 * Goes through all the particles owned by this Debris field and checks to see if any have gone out of range (i.e. the player/camera moved)
	 * If a particle has gone out of range, it is replaced with a new, randomly generated one
	 */
	public void update() {
		// update the location of the debris field
		this.location.x = following.location.x;
		this.location.y = following.location.y;
		this.location.z = following.location.z;

		// loop through all the particles
		for (int i = 0; i < numStars; i++) {
			Particle s = particles[i];
			// grab the particle's location
			float tempX = s.location.x;
			float tempY = s.location.y;
			float tempZ = s.location.z;

			// noise value generated by perlin noise used for changing star location
			float noise = (float) Noise.noise((double) s.location.x,
					(double) s.location.y, (double) s.location.z);
			
			/*
			 * This checks along all three axes to see if the particle has gone too far (it's location is > or < the location of the debris field + the distance the field was initialized with)
			 * If the particle has gone too far, it sets the location that the new star is generated at at the opposite end that it just left.
			 * So, if a particle goes too far on, say, the X axis in the positive direction (particle x > debris field x + distance) then it is replaces with a particle generated at the opposite end (debris field x - distance)
			 */
			if (s.location.x > this.location.x + distance)
				tempX = this.location.x - distance
						+ (noise * (JUMP_AMOUNT / 10));
			else if (s.location.x < this.location.x - distance)
				tempX = this.location.x + distance
						- (noise * (JUMP_AMOUNT / 10));

			if (s.location.z > this.location.z + distance)
				tempZ = this.location.z - distance
						+ (noise * (JUMP_AMOUNT / 10));
			else if (s.location.z < this.location.z - distance)
				tempZ = this.location.z + distance
						- (noise * (JUMP_AMOUNT / 10));

			if (s.location.y > this.location.y + distance)
				tempY = this.location.y - distance
						+ (noise * (JUMP_AMOUNT / 10));
			else if (s.location.y < this.location.y - distance)
				tempY = this.location.y + distance
						- (noise * (JUMP_AMOUNT / 10));

			// if the temporary location variables have changed at all, it means the particle we're checking has gone out of the debris field distance and that a new one needs to replace it
			if (tempX != s.location.x || tempY != s.location.y
					|| tempZ != s.location.z) {
				particles[i].destroy();
				particles[i] = getRandomParticle(tempX, tempY, tempZ);
			}
		}
	}

	/**
	 * Generates a random star based on previous star coordinates
	 * 
	 * @param prevX
	 *            X coordinate of previous star
	 * @param prevY
	 *            Y coordinate of previous star
	 * @param prevZ
	 *            Z coordinate of previous star
	 * @return A new random star
	 */
	public Particle getRandomParticle(float prevX, float prevY, float prevZ) {
		float x = prevX;
		float y = prevY;
		float z = prevZ;

		// noise value generated by perlin noise used for changing star location
		float noise = (float) (Noise.noise((double) x, (double) y, (double) z));

		
		// For each axis, this decides whether it wants to go up or down
		if (randy.nextBoolean())
			x += noise * JUMP_AMOUNT;
		else
			x -= noise * JUMP_AMOUNT;

		if (randy.nextBoolean())
			y += noise * JUMP_AMOUNT;
		else
			y -= noise * JUMP_AMOUNT;

		if (randy.nextBoolean()) {
			if (randy.nextBoolean())
				z += noise * (JUMP_AMOUNT / 2);
			else
				z -= noise * (JUMP_AMOUNT / 2);
		}

		float size = noise * 200.0f;
		Particle ret = new Particle(x, y, z, size);
		return ret;
	}

	@Override
	public void draw() {
		// we don't want lighting for our particles
		GL11.glDisable(GL11.GL_LIGHTING);
		
		// find the conjugate of the camera's quaternion and put it into the debris field's quaternion
		Quaternion.negate(Entities.camera.rotation, rotation);
		// put the rotation quaternion into the rotation buffer
		QuaternionHelper.toFloatBuffer(rotation, rotationBuffer);
		// bind a white texture and color
		TextureManager.getTexture(TextureManager.WHITE).bind();
		GL11.glColor3f(0.9f, 0.9f, 0.9f);
		
		// loop through all the particles to draw them
		for (Particle s : particles) {
			// how to translate to the star
			float transx = this.location.x - s.location.x;
			float transy = this.location.y - s.location.y;
			float transz = this.location.z - s.location.z;

			GL11.glPushMatrix();
			{
				// translate to the star's location
				GL11.glTranslatef(transx, transy, transz);

				// apply the reverse rotation
				GL11.glMultMatrix(rotationBuffer);

				// draw the star
				s.draw();
			}
			GL11.glPopMatrix();
		}

		// don't forget to re-enable lighting!
		GL11.glEnable(GL11.GL_LIGHTING);
	}

	/**
	 * A debris particle.
	 *
	 */
	private class Particle {
		/** the size of the particle */
		float size;
		/** the location of the particle*/
		Vector3f location;
		/** the call list for the particle to use when being drawn */
		int callList;

		public Particle(float x, float y, float z, float size) {
			location = new Vector3f(x, y, z);
			this.size = size;
			initList();
		}

		/**
		 * Initialize's the particles call list
		 */
		private void initList() {
			callList = GL11.glGenLists(1);
			
			// how smooth the circle is around the edges (smaller values = smoother)
			float step = 0.85f;

			GL11.glNewList(callList, GL11.GL_COMPILE);
			{
				GL11.glBegin(GL11.GL_TRIANGLE_FAN);
				{
					// tricky bit of code to make a perfect circle
					GL11.glVertex2f(0, 0);
					for (float angle = 0.0f; angle <= 360.0f; angle += step)
						GL11.glVertex3f((float) Math.sin(angle) * size,
								(float) Math.cos(angle) * size, 0.0f);
				}
				GL11.glEnd();
			}
			GL11.glEndList();
		}

		public void draw() {
			GL11.glCallList(callList);
		}

		public void destroy() {
			GL11.glDeleteLists(callList, 1);
		}
	}
}
